import os
from telebot import TeleBot
from dotenv import load_dotenv
import logging
from src.domain.exceptions import ProductNotFoundError
from .service_connector import service
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

load_dotenv()
BOT_TOKEN = os.getenv('BOT_TOKEN')
logger.info(f"Loaded BOT_TOKEN: {BOT_TOKEN[:10]}...")  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞—á–∞–ª–æ
if not BOT_TOKEN:
    logger.error('BOT_TOKEN not found in .env')
    raise ValueError('BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env')

bot = TeleBot(BOT_TOKEN, parse_mode='HTML')
logger.info("Bot initialized successfully")

def build_products_keyboard(products: list) -> InlineKeyboardMarkup:
    keyboard = []
    for product in products:
        keyboard.append([InlineKeyboardButton(
            text=product.name,
            callback_data=f"product:{product.id}"
        )])
    # –î–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É "–ù–∞–∑–∞–¥"
    keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_menu")])
    return InlineKeyboardMarkup(inline_keyboard=keyboard)

# –†–ê–ë–û–ß–ò–ô –í–ê–†–ò–ê–ù–¢
# def build_product_actions_keyboard(product_id: str, product_link: str) -> InlineKeyboardMarkup:
#     kb = InlineKeyboardMarkup(row_width=2)
#     kb.add(
#         InlineKeyboardButton("–û–±–Ω–æ–≤–∏—Ç—å —Ü–µ–Ω—É", callback_data=f"update_price:{product_id}"),
#         InlineKeyboardButton("–£–¥–∞–ª–∏—Ç—å —Ç–æ–≤–∞—Ä", callback_data=f"delete_product:{product_id}")
#     )
#     kb.add(InlineKeyboardButton("–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ Ozon", url=product_link))
#     return kb

# –ù–ï–†–ê–ë–û–ß–ò–ô –í–ê–†–ò–ê–ù–¢!
def build_product_actions_keyboard(product_id: str, product_link: str) -> InlineKeyboardMarkup:
    kb = InlineKeyboardMarkup(row_width=2)
    kb.add(
        InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Ü–µ–Ω—É", callback_data=f"update_price:{product_id}"),
        InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"delete_product:{product_id}")
    )
    kb.add(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_products"))
    kb.add(InlineKeyboardButton("–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ Ozon", url=product_link))
    return kb


    #kb.add(InlineKeyboardButton("–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ Ozon", url=product_link))

def format_product_message(product: dict) -> str:
    latest = product.get("latest_price") or {}
    with_card = latest.get("with_card")
    without_card = latest.get("without_card")
    default = latest.get("default")

    with_card_text = f"{with_card} ‚ÇΩ" if with_card is not None else "‚Äî"
    without_card_text = f"{without_card} ‚ÇΩ" if without_card is not None else "‚Äî"
    default_text = f"{default} ‚ÇΩ" if default is not None else "‚Äî"

    categories = product.get("categories")
    # categories –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ —Å—Ç—Ä–æ–∫–æ–π, –ª–∏–±–æ —Å–ø–∏—Å–∫–æ–º
    if isinstance(categories, (list, tuple)):
        categories_text = " > ".join(categories)
    else:
        categories_text = str(categories or "‚Äî")

    text = (
        f"üè∑Ô∏è <b>{product.get('name','(–±–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è)')}</b>\n"
        f"üî¢ ID: <code>{product.get('id')}</code>\n"
        f"üí≥ –¶–µ–Ω–∞ (—Å –∫–∞—Ä—Ç–æ–π): {with_card_text}\n"
        f"üí∏ –¶–µ–Ω–∞ (–±–µ–∑ –∫–∞—Ä—Ç—ã): {without_card_text}\n"
        f"üí† –ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞: {default_text}\n"
        f"‚≠ê –†–µ–π—Ç–∏–Ω–≥: {product.get('rating', '‚Äî')}\n"
        f"üóÇ –ö–∞—Ç–µ–≥–æ—Ä–∏–∏: {categories_text}\n\n"
        f"üîó <a href=\"{product.get('link')}\">–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ Ozon</a>"
    )
    return text

@bot.callback_query_handler(func=lambda call: call.data and call.data.startswith("product:"))
def handle_product_button(call: CallbackQuery):
    bot.answer_callback_query(call.id)
    product_id = call.data.split(":", 1)[1]

    try:
        product = service.get_full_product(product_id)  # –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å dict
        if not product:
            bot.send_message(call.message.chat.id, "‚ùå –¢–æ–≤–∞—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        text = format_product_message(product)  # —É —Ç–µ–±—è –≤ bot_instance —É–∂–µ –µ—Å—Ç—å
        kb = build_product_actions_keyboard(product_id=product["id"], product_link=product["link"])

        bot.edit_message_text(
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            text=text,
            parse_mode="HTML",
            reply_markup=kb,
            disable_web_page_preview=False
        )
    except ProductNotFoundError:
        bot.answer_callback_query(call.id, "‚ùå –¢–æ–≤–∞—Ä —É–¥–∞–ª—ë–Ω –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω")
    except Exception as e:
        logger.exception("–û—à–∏–±–∫–∞ –≤ handle_product_button")
        bot.answer_callback_query(call.id, f"–û—à–∏–±–∫–∞: {e}")